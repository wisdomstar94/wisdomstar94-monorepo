use std::{fs, path::PathBuf};
use rust_utils::{prompt::prompt, working_dir::get_working_dir_path_buf};
use glob::glob;

#[derive(clap::Args, Debug)]
#[command(
  about="package.json 프로젝트 내에 있는 모든 node_modules, dist 폴더를 삭제합니다.", 
  long_about = None
)]
pub struct CliArgs {
  
}

pub fn run(_: &CliArgs) {
  let node_modules_folder_path_info_list = get_node_modules_path_info_list();
  let dist_folder_path_info_list = get_dist_path_info_list();

  println!("\n------ 검색 된 node_modules 폴더 목록 (총 {}개) ------", &node_modules_folder_path_info_list.len());
  for x in &node_modules_folder_path_info_list {
    println!("{:?}", x.get_relative_path_str());
  }

  println!("\n------ 검색 된 dist 폴더 목록 (총 {}개) ------", &dist_folder_path_info_list.len());
  for x in &dist_folder_path_info_list {
    println!("{:?}", x.get_relative_path_str());
  }

  let total_len = &node_modules_folder_path_info_list.len() + &dist_folder_path_info_list.len();
  if total_len == 0 {
    println!("\n조회된 폴더가 없습니다.");
    return;
  }

  let answer = prompt(
    format!("\n위와 같이 조회 된 총 {}개의 폴더 들을 삭제하시겠습니까? (Y/N) : ", &total_len).as_str(), 
    "63d27b11-28ad-426e-a8ca-af2214950ffe"
  );

  let answer_lowercase = &answer.to_lowercase();
  println!("answer_lowercase: {:?}", answer_lowercase);

  if answer_lowercase != "y" {
    return;
  }

  println!("삭제 진행중입니다...");

  for path_info in &node_modules_folder_path_info_list {
    fs::remove_dir_all(path_info.get_path_buf()).unwrap();
  }

  for path_info in &dist_folder_path_info_list {
    fs::remove_dir_all(path_info.get_path_buf()).unwrap();
  } 

  println!("삭제가 완료되었습니다. :)");
} 

// ------------------------------------------------------------------------------------------------- //

#[derive(Debug)]
pub struct PathInfo {
  path_buf: PathBuf,
  absolute_path_str: String,
  relative_path_str: String
}

impl PathInfo {
  pub fn new(path_buf: PathBuf, absolute_path_str: String, relative_path_str: String) -> Self {
    Self {
      path_buf,
      absolute_path_str,
      relative_path_str
    }
  }

  pub fn get_path_buf(&self) -> &PathBuf {
    &self.path_buf
  }

  pub fn get_absolute_path_str(&self) -> &str {
    &self.absolute_path_str
  }

  pub fn get_relative_path_str(&self) -> &str {
    &self.relative_path_str
  }
}

fn get_node_modules_path_info_list() -> Vec<PathInfo> {
  let working_dir_path_buf = get_working_dir_path_buf().expect("[30e75a70-f8c6-4a57-ae2f-a822ec981d74] working dir 경로를 불러오지 못했습니다!");
  let working_dir_path_str = working_dir_path_buf.to_str().expect("[c2e9e89b-7130-4573-a75e-3920b4a686ff] working dir 경로를 str 로 반환하는데 에러가 발생하였습나다.");

  let target_glob_path_buf = working_dir_path_buf.join("**").join("node_modules");
  let target_glob_str = target_glob_path_buf.as_path().to_str().unwrap();

  let mut path_info_vec: Vec<PathInfo> = Vec::new();

  for entry in glob(target_glob_str).expect("Failed to read glob pattern") {
    if let Ok(path_buf) = &entry {
      let absolute_path_str = path_buf.to_str().unwrap();
      let relative_path_str = absolute_path_str.replace(working_dir_path_str, ""); 

      let vec: Vec<&str> = relative_path_str.split("node_modules").collect();
      if vec.len() > 2 {
        continue;
      }

      path_info_vec.push(PathInfo::new(path_buf.clone(), absolute_path_str.to_string(), relative_path_str.to_string()));
    }
  }

  path_info_vec
}

fn get_dist_path_info_list() -> Vec<PathInfo> {
  let working_dir_path_buf = get_working_dir_path_buf().expect("[9d059557-a73f-43d9-b938-3df1df0104be] working dir 경로를 불러오지 못했습니다!");
  let working_dir_path_str = working_dir_path_buf.to_str().expect("[13c1269c-7fbf-4e0f-adb7-126e5bfa7329] working dir 경로를 str 로 반환하는데 에러가 발생하였습나다.");

  let target_glob_path_buf = working_dir_path_buf.join("**").join("dist");
  let target_glob_str = target_glob_path_buf.as_path().to_str().unwrap();

  let mut path_info_vec: Vec<PathInfo> = Vec::new();

  for entry in glob(target_glob_str).expect("Failed to read glob pattern") {
    if let Ok(path_buf) = &entry {
      let absolute_path_str = path_buf.to_str().unwrap();
      let relative_path_str = absolute_path_str.replace(working_dir_path_str, ""); 

      let vec: Vec<&str> = relative_path_str.split("dist").collect();
      if vec.len() > 2 {
        continue;
      }
      if relative_path_str.contains("node_modules") {
        continue;
      }

      if let Ok(path_buf) = &entry {
        path_info_vec.push(PathInfo::new(path_buf.clone(), absolute_path_str.to_string(), relative_path_str.to_string()));
      }
    }
  }

  path_info_vec
}